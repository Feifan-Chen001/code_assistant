from __future__ import annotations
from typing import List, Dict, Any, Optional

PYTEST_HEADER = """# Auto-generated by CodeAssistant
import pytest
"""

HYPOTHESIS_HEADER = """from hypothesis import given, strategies as st
"""


def make_test_module(
    module_rel: str,
    funcs: List[Dict[str, Any]],
    use_hypothesis: bool,
    module_path: Optional[str] = None,
    module_name: Optional[str] = None,
    repo_root: Optional[str] = None,
) -> str:
    lines = [PYTEST_HEADER]
    if use_hypothesis:
        lines.append(HYPOTHESIS_HEADER)

    # Make imports robust across "src/" layout repos and when tests live outside the repo root.
    if repo_root:
        lines.append("import sys")
        lines.append("from pathlib import Path\n")
        lines.append(f"REPO_ROOT = (Path(__file__).parent / {repo_root!r}).resolve()")
        lines.append("if str(REPO_ROOT) not in sys.path:")
        lines.append("    sys.path.insert(0, str(REPO_ROOT))")
        lines.append("REPO_SRC = REPO_ROOT / 'src'")
        lines.append("if REPO_SRC.exists() and str(REPO_SRC) not in sys.path:")
        lines.append("    sys.path.insert(0, str(REPO_SRC))\n")

    if module_path:
        name = module_name or "notebook_module"
        lines.append("import importlib.util")
        lines.append("from pathlib import Path\n")
        lines.append(f"MOD_PATH = Path(__file__).parent / {module_path!r}")
        lines.append(f"MOD_NAME = {name!r}")
        lines.append("spec = importlib.util.spec_from_file_location(MOD_NAME, MOD_PATH)")
        lines.append("MOD = importlib.util.module_from_spec(spec)")
        lines.append("assert spec and spec.loader")
        lines.append("spec.loader.exec_module(MOD)\n")
    else:
        mod = module_rel.replace("/", ".").replace(".py", "")
        lines.append("import importlib\n")
        lines.append(f"MOD = importlib.import_module('{mod}')\n")

    for f in funcs:
        name = f["name"]
        args = f["args"]
        call_args = ", ".join(["None" for _ in args])

        lines.append(f"\n\ndef test_{name}__basic_smoke():")
        lines.append("    try:")
        lines.append(f"        out = getattr(MOD, '{name}')({call_args})")
        lines.append("    except TypeError:")
        lines.append("        pytest.skip('signature mismatch for template call')")
        lines.append("        return")
        lines.append("    assert out is not None or out is None\n")

        lines.append(f"\n\ndef test_{name}__edge_cases():")
        lines.append("    # TODO: add domain-specific edge cases when known")
        lines.append("    assert True\n")

        if use_hypothesis:
            lines.append("@given(st.integers(), st.integers())")
            lines.append(f"def test_{name}__property_based(a, b):")
            lines.append("    try:")
            lines.append(f"        _ = getattr(MOD, '{name}')(a, b)")
            lines.append("    except TypeError:")
            lines.append("        pytest.skip('signature mismatch for hypothesis template')\n")

    return "\n".join(lines)
